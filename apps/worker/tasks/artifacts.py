"""Artifact generation tasks."""
import csv
import hashlib
import json
import os
import uuid
from datetime import datetime
from pathlib import Path

from jinja2 import Template
from sqlalchemy import select

from worker import app
from database import SessionLocal
from models import (
    Artifact, ArtifactStatus, League, Season, StatsSnapshot, AuditLog, AuditAction
)
from config import settings


DIGEST_TEMPLATE = """# {{ league_name }} - {{ season_name }}

**Generated:** {{ generated_at }}

---

## League Summary

- **Total Matches:** {{ n_matches }}
- **Active Players:** {{ n_players }}
{% if sample_note %}- *{{ sample_note }}*{% endif %}

{% if top_mover %}
### Rising Star
**{{ top_mover.nickname }}** {% if top_mover.change > 0 %}gained{% else %}lost{% endif %} **{{ top_mover.change|abs }} Elo** points this period, moving from {{ top_mover.old_rating }} to {{ top_mover.new_rating }}.
{% endif %}

---

## Elo Leaderboard

| Rank | Player | Rating | Matches |
|------|--------|--------|---------|
{% for entry in elo_top %}| {{ entry.rank }} | **{{ entry.nickname }}** | {{ entry.value }} | {{ entry.n_matches }} |
{% endfor %}

{% if n_matches >= 10 %}
## Win Rate Leaders

| Rank | Player | Win Rate | Matches |
|------|--------|----------|---------|
{% for entry in win_rate_top %}| {{ entry.rank }} | **{{ entry.nickname }}** | {{ "%.1f"|format(entry.value * 100) }}% | {{ entry.n_matches }} |
{% endfor %}

*Win rate requires minimum 5 matches to qualify.*
{% endif %}

{% if best_duos %}
---

## Dynamic Duos

The most effective partnerships in 2v2 matches:

{% for duo in best_duos %}
{{ loop.index }}. **{{ duo.player1_nickname }} & {{ duo.player2_nickname }}**
   - Win Rate: {{ "%.1f"|format(duo.win_rate * 100) }}%
   - Record: {{ duo.wins }}W - {{ duo.losses }}L ({{ duo.n_matches }} matches)
{% endfor %}

*Duo stats require minimum 3 matches together.*
{% endif %}

{% if top_rivalries %}
---

## Top Rivalries

The most contested head-to-head matchups:

{% for r in top_rivalries %}
{{ loop.index }}. **{{ r.player1_nickname }}** vs **{{ r.player2_nickname }}**
   - Score: {{ r.player1_wins }} - {{ r.player2_wins }}
   - Total: {{ r.n_matches }} matches
   {% if r.player1_wins > r.player2_wins %}- *{{ r.player1_nickname }} leads*{% elif r.player2_wins > r.player1_wins %}- *{{ r.player2_nickname }} leads*{% else %}- *Tied*{% endif %}

{% endfor %}
{% endif %}

{% if streak_info %}
---

## Streaks

- **Current Hot Streak:** {{ streak_info.hot_player }} ({{ streak_info.hot_streak }} wins)
{% if streak_info.cold_player %}- **Cold Streak:** {{ streak_info.cold_player }} ({{ streak_info.cold_streak }} losses){% endif %}
{% endif %}

---

*This report is deterministically generated from match data.*
*Source hash: {{ source_hash }}*
*Generated by FoosPulse v1.0*
"""


def compute_file_hash(filepath: Path) -> str:
    """Compute SHA256 hash of file."""
    sha256 = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256.update(chunk)
    return sha256.hexdigest()


@app.task(bind=True, queue="artifacts", max_retries=5)
def generate_league_report_artifacts(self, artifact_id: str):
    """Generate league report artifacts."""
    try:
        with SessionLocal() as db:
            artifact_uuid = uuid.UUID(artifact_id)
            
            artifact = db.execute(
                select(Artifact).where(Artifact.id == artifact_uuid)
            ).scalar_one_or_none()
            
            if not artifact:
                return {"error": "Artifact not found"}
            
            if artifact.status != ArtifactStatus.QUEUED:
                return {"skipped": f"Artifact status is {artifact.status.value}"}
            
            # Mark as running
            artifact.status = ArtifactStatus.RUNNING
            db.commit()
            
            try:
                # Get league and season info
                league = db.execute(
                    select(League).where(League.id == artifact.league_id)
                ).scalar_one_or_none()
                
                season = db.execute(
                    select(Season).where(Season.id == artifact.season_id)
                ).scalar_one_or_none()
                
                if not league or not season:
                    raise ValueError("League or season not found")
                
                # Get latest stats snapshots
                leaderboards_snapshot = db.execute(
                    select(StatsSnapshot)
                    .where(StatsSnapshot.league_id == artifact.league_id)
                    .where(StatsSnapshot.season_id == artifact.season_id)
                    .where(StatsSnapshot.snapshot_type == "leaderboards")
                    .order_by(StatsSnapshot.computed_at.desc())
                ).scalar_one_or_none()
                
                synergy_snapshot = db.execute(
                    select(StatsSnapshot)
                    .where(StatsSnapshot.league_id == artifact.league_id)
                    .where(StatsSnapshot.season_id == artifact.season_id)
                    .where(StatsSnapshot.snapshot_type == "synergy")
                    .order_by(StatsSnapshot.computed_at.desc())
                ).scalar_one_or_none()
                
                matchups_snapshot = db.execute(
                    select(StatsSnapshot)
                    .where(StatsSnapshot.league_id == artifact.league_id)
                    .where(StatsSnapshot.season_id == artifact.season_id)
                    .where(StatsSnapshot.snapshot_type == "matchups")
                    .order_by(StatsSnapshot.computed_at.desc())
                ).scalar_one_or_none()
                
                source_hash = leaderboards_snapshot.source_hash if leaderboards_snapshot else "none"
                
                # Create output directory
                output_dir = Path(settings.artifacts_dir) / league.slug / str(season.id) / artifact.run_id
                output_dir.mkdir(parents=True, exist_ok=True)
                
                leaderboards = leaderboards_snapshot.data_json if leaderboards_snapshot else {}
                synergy = synergy_snapshot.data_json if synergy_snapshot else {}
                matchups = matchups_snapshot.data_json if matchups_snapshot else []
                
                # Generate files
                files = []
                
                # stats.json
                stats_data = {
                    "league_id": str(league.id),
                    "league_name": league.name,
                    "season_id": str(season.id),
                    "season_name": season.name,
                    "source_hash": source_hash,
                    "generated_at": datetime.utcnow().isoformat(),
                    "leaderboards": leaderboards,
                    "synergy": synergy,
                    "matchups": matchups
                }
                stats_path = output_dir / "stats.json"
                with open(stats_path, "w") as f:
                    json.dump(stats_data, f, indent=2, sort_keys=True)
                files.append(("stats.json", stats_path))
                
                # leaderboards.csv
                lb_path = output_dir / "leaderboards.csv"
                with open(lb_path, "w", newline="") as f:
                    writer = csv.writer(f)
                    writer.writerow(["board", "rank", "player_id", "nickname", "value", "n_matches"])
                    for board_name, board_data in sorted(leaderboards.items()):
                        for entry in board_data.get("entries", []):
                            writer.writerow([
                                board_name, entry["rank"], entry["player_id"],
                                entry["nickname"], entry["value"], entry["n_matches"]
                            ])
                files.append(("leaderboards.csv", lb_path))
                
                # synergy_matrix.csv
                synergy_path = output_dir / "synergy_matrix.csv"
                with open(synergy_path, "w", newline="") as f:
                    writer = csv.writer(f)
                    writer.writerow(["type", "player1_id", "player1_nickname", "player2_id", "player2_nickname", "wins", "losses", "win_rate", "n_matches"])
                    for duo in synergy.get("best_duos", []):
                        writer.writerow(["best", duo["player1_id"], duo["player1_nickname"], duo["player2_id"], duo["player2_nickname"], duo["wins"], duo["losses"], duo["win_rate"], duo["n_matches"]])
                    for duo in synergy.get("worst_duos", []):
                        writer.writerow(["worst", duo["player1_id"], duo["player1_nickname"], duo["player2_id"], duo["player2_nickname"], duo["wins"], duo["losses"], duo["win_rate"], duo["n_matches"]])
                files.append(("synergy_matrix.csv", synergy_path))
                
                # matchups.csv
                matchups_path = output_dir / "matchups.csv"
                with open(matchups_path, "w", newline="") as f:
                    writer = csv.writer(f)
                    writer.writerow(["player1_id", "player1_nickname", "player2_id", "player2_nickname", "player1_wins", "player2_wins", "n_matches"])
                    for m in matchups:
                        writer.writerow([m["player1_id"], m["player1_nickname"], m["player2_id"], m["player2_nickname"], m["player1_wins"], m["player2_wins"], m["n_matches"]])
                files.append(("matchups.csv", matchups_path))
                
                # league_digest.md
                elo_entries = leaderboards.get("elo", {}).get("entries", [])[:5]
                win_rate_entries = leaderboards.get("win_rate", {}).get("entries", [])[:5]
                n_players = len(elo_entries)
                total_matches = sum(e["n_matches"] for e in elo_entries) // max(n_players, 1)

                # Compute top mover (if Elo changes available)
                top_mover = None
                elo_change_entries = leaderboards.get("elo_change", {}).get("entries", [])
                if elo_change_entries:
                    top_entry = elo_change_entries[0]
                    if abs(top_entry.get("value", 0)) > 0:
                        current_elo = next(
                            (e["value"] for e in elo_entries if e["player_id"] == top_entry["player_id"]),
                            1200
                        )
                        top_mover = {
                            "nickname": top_entry["nickname"],
                            "change": top_entry["value"],
                            "old_rating": current_elo - top_entry["value"],
                            "new_rating": current_elo
                        }

                # Streak info
                streak_info = None
                streak_entries = leaderboards.get("win_streak", {}).get("entries", [])
                if streak_entries and streak_entries[0].get("value", 0) >= 3:
                    streak_info = {
                        "hot_player": streak_entries[0]["nickname"],
                        "hot_streak": streak_entries[0]["value"],
                        "cold_player": None,
                        "cold_streak": None
                    }

                # Sample size note
                sample_note = None
                if total_matches < 10:
                    sample_note = "Stats are preliminary - more matches needed for reliable rankings."
                elif total_matches < 50:
                    sample_note = "Rankings are stabilizing as more matches are played."

                template = Template(DIGEST_TEMPLATE)
                digest_content = template.render(
                    league_name=league.name,
                    season_name=season.name,
                    generated_at=datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
                    n_matches=total_matches,
                    n_players=n_players,
                    elo_top=elo_entries,
                    win_rate_top=win_rate_entries,
                    best_duos=synergy.get("best_duos", [])[:3],
                    top_rivalries=matchups[:3],
                    top_mover=top_mover,
                    streak_info=streak_info,
                    sample_note=sample_note,
                    source_hash=source_hash
                )
                digest_path = output_dir / "league_digest.md"
                with open(digest_path, "w") as f:
                    f.write(digest_content)
                files.append(("league_digest.md", digest_path))
                
                # Create manifest
                manifest = {
                    "generator": "deterministic_v1",
                    "generated_at": datetime.utcnow().isoformat(),
                    "source_hash": source_hash,
                    "files": []
                }
                
                for filename, filepath in files:
                    file_hash = compute_file_hash(filepath)
                    file_size = filepath.stat().st_size
                    manifest["files"].append({
                        "filename": filename,
                        "sha256": file_hash,
                        "size_bytes": file_size
                    })
                
                # Write manifest
                manifest_path = output_dir / "manifest.json"
                with open(manifest_path, "w") as f:
                    json.dump(manifest, f, indent=2, sort_keys=True)
                
                # Update artifact
                artifact.status = ArtifactStatus.DONE
                artifact.output_path = str(output_dir)
                artifact.manifest_json = manifest
                artifact.source_hash = source_hash
                artifact.completed_at = datetime.utcnow()

                # Audit log for completion
                audit_entry = AuditLog(
                    action=AuditAction.ARTIFACT_COMPLETE.value,
                    entity_type="artifact",
                    entity_id=artifact_uuid,
                    league_id=artifact.league_id,
                    payload_json={
                        "source_hash": source_hash,
                        "files": [f[0] for f in files]
                    },
                    description=f"Artifact generation completed: {len(files)} files",
                    created_at=datetime.utcnow()
                )
                db.add(audit_entry)

                db.commit()
                
                return {
                    "artifact_id": artifact_id,
                    "status": "done",
                    "output_path": str(output_dir),
                    "files": [f[0] for f in files]
                }
                
            except Exception as e:
                artifact.status = ArtifactStatus.FAILED
                artifact.error_message = str(e)
                artifact.completed_at = datetime.utcnow()

                # Audit log for failure
                audit_entry = AuditLog(
                    action=AuditAction.ARTIFACT_FAIL.value,
                    entity_type="artifact",
                    entity_id=artifact_uuid,
                    league_id=artifact.league_id,
                    payload_json={"error": str(e)[:500]},
                    description=f"Artifact generation failed: {str(e)[:100]}",
                    created_at=datetime.utcnow()
                )
                db.add(audit_entry)

                db.commit()
                raise
                
    except Exception as e:
        raise self.retry(exc=e, countdown=2 ** self.request.retries)
